from sympy import *
from sympy import poly
from sympy.abc import x, y, z
from sympy import LC
from sympy import LT
from sympy import subresultants

# computes de reductum of the polynomial F, as a polynomial of I_r[x]
def red(F, x):
	p = F - LT(F, x)
	return p

# computes de reducta (RED) of the polynomial F, as a polynomial of I_r[x]
def reducta(F, x):
	L = []
	aux = F 
	while(aux != 0):
		L.append(aux)
		aux = red(aux, x)
	
	return L 

# exemple del llibre (o l'article)
# p = poly((x**2 +y**2 - 1)*z**3 + (x-1)*z**2 + (x-1)**2 + y**2)
# p 
# red(p, z)
# reducta(p, z)

# no esta gens refinat a nivell de cost 
# especialment tota la part de fer dos RED, esta fatal en aquest sentit

# computes the operation PROJ (not all the projection fase)
# projection of the polynomials in A, as polynomials of I_r[x]
def PROJ(A, x):
	P = []   # this will be the output set
			# estic usant les operacions de list, pero al final es fa list(set(P)) i elimina els duplicats
	# F is a polynomial in A 
	for F in A:
		R = reducta(F, x)
		
		for G in R:
			P.append( LC(G, x))
			H = diff(G, x)
			PSC = []
			
			# n = min(deg(G), deg(H))
			# for i in range(n):
				# psc_j(G,H)
			
			P.append( prs(G, H) )   # mirar exactament que volem
									# crec que això no dona el que volem. el for començat a sobre és per si es necessita per a obtenir el PSC(G, H)
			for I in A:
				if(I == F):
					break
				else:
					S = reducta(I, x)
					for J in S:
						P.append( prs(G, J) )
						
	return list(set(P))
